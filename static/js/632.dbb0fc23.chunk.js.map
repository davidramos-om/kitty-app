{"version":3,"file":"static/js/632.dbb0fc23.chunk.js","mappings":"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","sources":["../node_modules/@mui/material/internal/svg-icons/Person.js","../node_modules/@mui/material/Avatar/avatarClasses.js","../node_modules/@mui/material/Avatar/Avatar.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../node_modules/graphql-tag/src/index.ts","../node_modules/numeral/numeral.js","../node_modules/@apollo/src/react/parser/index.ts","../node_modules/@apollo/src/react/hooks/useQuery.ts","../node_modules/@apollo/src/react/hooks/useApolloClient.ts"],"sourcesContent":["import * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n/**\n * @ignore - internal component.\n */\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"\n}), 'Person');","import { generateUtilityClass, generateUtilityClasses } from '@mui/base';\nexport function getAvatarUtilityClass(slot) {\n  return generateUtilityClass('MuiAvatar', slot);\n}\nconst avatarClasses = generateUtilityClasses('MuiAvatar', ['root', 'colorDefault', 'circular', 'rounded', 'square', 'img', 'fallback']);\nexport default avatarClasses;","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"alt\", \"children\", \"className\", \"component\", \"imgProps\", \"sizes\", \"src\", \"srcSet\", \"variant\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport Person from '../internal/svg-icons/Person';\nimport { getAvatarUtilityClass } from './avatarClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    variant,\n    colorDefault\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, colorDefault && 'colorDefault'],\n    img: ['img'],\n    fallback: ['fallback']\n  };\n  return composeClasses(slots, getAvatarUtilityClass, classes);\n};\n\nconst AvatarRoot = styled('div', {\n  name: 'MuiAvatar',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], ownerState.colorDefault && styles.colorDefault];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  position: 'relative',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  flexShrink: 0,\n  width: 40,\n  height: 40,\n  fontFamily: theme.typography.fontFamily,\n  fontSize: theme.typography.pxToRem(20),\n  lineHeight: 1,\n  borderRadius: '50%',\n  overflow: 'hidden',\n  userSelect: 'none'\n}, ownerState.variant === 'rounded' && {\n  borderRadius: theme.shape.borderRadius\n}, ownerState.variant === 'square' && {\n  borderRadius: 0\n}, ownerState.colorDefault && {\n  color: theme.palette.background.default,\n  backgroundColor: theme.palette.mode === 'light' ? theme.palette.grey[400] : theme.palette.grey[600]\n}));\nconst AvatarImg = styled('img', {\n  name: 'MuiAvatar',\n  slot: 'Img',\n  overridesResolver: (props, styles) => styles.img\n})({\n  width: '100%',\n  height: '100%',\n  textAlign: 'center',\n  // Handle non-square image. The property isn't supported by IE11.\n  objectFit: 'cover',\n  // Hide alt text.\n  color: 'transparent',\n  // Hide the image broken icon, only works on Chrome.\n  textIndent: 10000\n});\nconst AvatarFallback = styled(Person, {\n  name: 'MuiAvatar',\n  slot: 'Fallback',\n  overridesResolver: (props, styles) => styles.fallback\n})({\n  width: '75%',\n  height: '75%'\n});\n\nfunction useLoaded({\n  crossOrigin,\n  referrerPolicy,\n  src,\n  srcSet\n}) {\n  const [loaded, setLoaded] = React.useState(false);\n  React.useEffect(() => {\n    if (!src && !srcSet) {\n      return undefined;\n    }\n\n    setLoaded(false);\n    let active = true;\n    const image = new Image();\n\n    image.onload = () => {\n      if (!active) {\n        return;\n      }\n\n      setLoaded('loaded');\n    };\n\n    image.onerror = () => {\n      if (!active) {\n        return;\n      }\n\n      setLoaded('error');\n    };\n\n    image.crossOrigin = crossOrigin;\n    image.referrerPolicy = referrerPolicy;\n    image.src = src;\n\n    if (srcSet) {\n      image.srcset = srcSet;\n    }\n\n    return () => {\n      active = false;\n    };\n  }, [crossOrigin, referrerPolicy, src, srcSet]);\n  return loaded;\n}\n\nconst Avatar = /*#__PURE__*/React.forwardRef(function Avatar(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiAvatar'\n  });\n\n  const {\n    alt,\n    children: childrenProp,\n    className,\n    component = 'div',\n    imgProps,\n    sizes,\n    src,\n    srcSet,\n    variant = 'circular'\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, _excluded);\n\n  let children = null; // Use a hook instead of onError on the img element to support server-side rendering.\n\n  const loaded = useLoaded(_extends({}, imgProps, {\n    src,\n    srcSet\n  }));\n  const hasImg = src || srcSet;\n  const hasImgNotFailing = hasImg && loaded !== 'error';\n\n  const ownerState = _extends({}, props, {\n    colorDefault: !hasImgNotFailing,\n    component,\n    variant\n  });\n\n  const classes = useUtilityClasses(ownerState);\n\n  if (hasImgNotFailing) {\n    children = /*#__PURE__*/_jsx(AvatarImg, _extends({\n      alt: alt,\n      src: src,\n      srcSet: srcSet,\n      sizes: sizes,\n      ownerState: ownerState,\n      className: classes.img\n    }, imgProps));\n  } else if (childrenProp != null) {\n    children = childrenProp;\n  } else if (hasImg && alt) {\n    children = alt[0];\n  } else {\n    children = /*#__PURE__*/_jsx(AvatarFallback, {\n      className: classes.fallback\n    });\n  }\n\n  return /*#__PURE__*/_jsx(AvatarRoot, _extends({\n    as: component,\n    ownerState: ownerState,\n    className: clsx(classes.root, className),\n    ref: ref\n  }, other, {\n    children: children\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Avatar.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * Used in combination with `src` or `srcSet` to\n   * provide an alt attribute for the rendered `img` element.\n   */\n  alt: PropTypes.string,\n\n  /**\n   * Used to render icon or text elements inside the Avatar if `src` is not set.\n   * This can be an element, or just a string.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attributes) applied to the `img` element if the component is used to display an image.\n   * It can be used to listen for the loading error event.\n   */\n  imgProps: PropTypes.object,\n\n  /**\n   * The `sizes` attribute for the `img` element.\n   */\n  sizes: PropTypes.string,\n\n  /**\n   * The `src` attribute for the `img` element.\n   */\n  src: PropTypes.string,\n\n  /**\n   * The `srcSet` attribute for the `img` element.\n   * Use this attribute for responsive image display.\n   */\n  srcSet: PropTypes.string,\n\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n\n  /**\n   * The shape of the avatar.\n   * @default 'circular'\n   */\n  variant: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .oneOfType([PropTypes.oneOf(['circular', 'rounded', 'square']), PropTypes.string])\n} : void 0;\nexport default Avatar;","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorArgs` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedArgs(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, undefined, source, [\n    position,\n  ]);\n}\n","/**\n * The set of allowed directive location values.\n */\nexport let DirectiveLocation;\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport let TokenKind;\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n","/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        global.numeral = factory();\n    }\n}(this, function () {\n    /************************************\n        Variables\n    ************************************/\n\n    var numeral,\n        _,\n        VERSION = '2.0.6',\n        formats = {},\n        locales = {},\n        defaults = {\n            currentLocale: 'en',\n            zeroFormat: null,\n            nullFormat: null,\n            defaultFormat: '0,0',\n            scalePercentBy100: true\n        },\n        options = {\n            currentLocale: defaults.currentLocale,\n            zeroFormat: defaults.zeroFormat,\n            nullFormat: defaults.nullFormat,\n            defaultFormat: defaults.defaultFormat,\n            scalePercentBy100: defaults.scalePercentBy100\n        };\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n\n        this._value = number;\n    }\n\n    numeral = function(input) {\n        var value,\n            kind,\n            unformatFunction,\n            regexp;\n\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === 'string') {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                for (kind in formats) {\n                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n\n                        break;\n                    }\n                }\n\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input)|| null;\n        }\n\n        return new Numeral(input, value);\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale],\n                negP = false,\n                optDec = false,\n                leadingCount = 0,\n                abbr = '',\n                trillion = 1000000000000,\n                billion = 1000000000,\n                million = 1000000,\n                thousand = 1000,\n                decimal = '',\n                neg = false,\n                abbrForce, // force abbreviation\n                abs,\n                min,\n                max,\n                power,\n                int,\n                precision,\n                signed,\n                thousands,\n                output;\n\n            // make sure we never format a null value\n            value = value || 0;\n\n            abs = Math.abs(value);\n\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, '(')) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, '');\n            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {\n                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n                format = format.replace(/[\\+|\\-]/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, 'a')) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n\n                abbrForce = abbrForce ? abbrForce[1] : false;\n\n                // check for space before abbreviation\n                if (numeral._.includes(format, ' a')) {\n                    abbr = ' ';\n                }\n\n                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n                if (abs >= trillion && !abbrForce || abbrForce === 't') {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n\n            // check for optional decimals\n            if (numeral._.includes(format, '[.]')) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            // break number and format\n            int = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n            if (precision) {\n                if (numeral._.includes(precision, '[')) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n\n                int = decimal.split('.')[0];\n\n                if (numeral._.includes(decimal, '.')) {\n                    decimal = locale.delimiters.decimal + decimal.split('.')[1];\n                } else {\n                    decimal = '';\n                }\n\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = '';\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n\n                switch (abbr) {\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n\n\n            // format number\n            if (numeral._.includes(int, '-')) {\n                int = int.slice(1);\n                neg = true;\n            }\n\n            if (int.length < leadingCount) {\n                for (var i = leadingCount - int.length; i > 0; i--) {\n                    int = '0' + int;\n                }\n            }\n\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + locale.delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                int = '';\n            }\n\n            output = int + decimal + (abbr ? abbr : '');\n\n            if (negP) {\n                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n                } else if (neg) {\n                    output = '-' + output;\n                }\n            }\n\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale],\n                stringOriginal = string,\n                abbreviations = {\n                    thousand: 3,\n                    million: 6,\n                    billion: 9,\n                    trillion: 12\n                },\n                abbreviation,\n                value,\n                i,\n                regexp;\n\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                value = 1;\n\n                if (locale.delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(locale.delimiters.decimal, '.');\n                }\n\n                for (abbreviation in abbreviations) {\n                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\\\)|(\\\\' + locale.currency.symbol + ')?(?:\\\\))?)?$');\n\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n\n                // check for negative number\n                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;\n\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, '');\n\n                value *= Number(string);\n            }\n\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === 'number' && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/) {\n            if (this === null) {\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var t = Object(array),\n                len = t.length >>> 0,\n                k = 0,\n                value;\n\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while (k < len && !(k in t)) {\n                    k++;\n                }\n\n                if (k >= len) {\n                    throw new TypeError('Reduce of empty array with no initial value');\n                }\n\n                value = t[k++];\n            }\n            for (; k < len; k++) {\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */\n        multiplier: function (x) {\n            var parts = x.toString().split('.');\n\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */\n        correctionFactor: function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */\n        toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split('.'),\n                minDecimals = maxDecimals - (optionals || 0),\n                boundedPrecision,\n                optionalsRegExp,\n                power,\n                output;\n\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n              boundedPrecision = minDecimals;\n            }\n\n            power = Math.pow(10, boundedPrecision);\n\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n                output = output.replace(optionalsRegExp, '');\n            }\n\n            return output;\n        }\n    };\n\n    // avaliable options\n    numeral.options = options;\n\n    // avaliable formats\n    numeral.formats = formats;\n\n    // avaliable formats\n    numeral.locales = locales;\n\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n\n        return options.currentLocale;\n    };\n\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n\n        key = key.toLowerCase();\n\n        if (!locales[key]) {\n            throw new Error('Unknown locale : ' + key);\n        }\n\n        return locales[key];\n    };\n\n    numeral.reset = function() {\n        for (var property in defaults) {\n            options[property] = defaults[property];\n        }\n    };\n\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.nullFormat = function (format) {\n        options.nullFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n\n        if (this[type + 's'][name]) {\n            throw new TypeError(name + ' ' + type + ' already registered.');\n        }\n\n        this[type + 's'][name] = format;\n\n        return format;\n    };\n\n\n    numeral.validate = function(val, culture) {\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            localeData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n\n            if (console.warn) {\n                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value,\n                format = inputString || options.defaultFormat,\n                kind,\n                output,\n                formatFunction;\n\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for (kind in formats) {\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n\n                        break;\n                    }\n                }\n\n                formatFunction = formatFunction || numeral._.numberToFormat;\n\n                output = formatFunction(value, format, roundingFunction);\n            }\n\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;\n\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;\n\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 1);\n\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback);\n\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n\n    /************************************\n        Default Locale && Format\n    ************************************/\n\n    numeral.register('locale', 'en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    \n\n(function() {\n        numeral.register('format', 'bps', {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, ' BPS') ? ' ' : '',\n                    output;\n\n                value = value * 10000;\n\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, '');\n\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n\n                if (numeral._.includes(output, ')')) {\n                    output = output.split('');\n\n                    output.splice(-1, 0, space + 'BPS');\n\n                    output = output.join('');\n                } else {\n                    output = output + space + 'BPS';\n                }\n\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n})();\n\n\n(function() {\n        var decimal = {\n            base: 1000,\n            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        },\n        binary = {\n            base: 1024,\n            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n        };\n\n    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join('|');\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';\n\n    numeral.register('format', 'bytes', {\n        regexps: {\n            format: /([0\\s]i?b)/,\n            unformat: new RegExp(unformatRegex)\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                bytes = numeral._.includes(format, 'ib') ? binary : decimal,\n                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',\n                power,\n                min,\n                max;\n\n            // check for space before\n            format = format.replace(/\\s?i?b/, '');\n\n            for (power = 0; power <= bytes.suffixes.length; power++) {\n                min = Math.pow(bytes.base, power);\n                max = Math.pow(bytes.base, power + 1);\n\n                if (value === null || value === 0 || value >= min && value < max) {\n                    suffix += bytes.suffixes[power];\n\n                    if (min > 0) {\n                        value = value / min;\n                    }\n\n                    break;\n                }\n            }\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + suffix;\n        },\n        unformat: function(string) {\n            var value = numeral._.stringToNumber(string),\n                power,\n                bytesMultiplier;\n\n            if (value) {\n                for (power = decimal.suffixes.length - 1; power >= 0; power--) {\n                    if (numeral._.includes(string, decimal.suffixes[power])) {\n                        bytesMultiplier = Math.pow(decimal.base, power);\n\n                        break;\n                    }\n\n                    if (numeral._.includes(string, binary.suffixes[power])) {\n                        bytesMultiplier = Math.pow(binary.base, power);\n\n                        break;\n                    }\n                }\n\n                value *= (bytesMultiplier || 1);\n            }\n\n            return value;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'currency', {\n        regexps: {\n            format: /(\\$)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                },\n                output,\n                symbol,\n                i;\n\n            // strip format of spaces and $\n            format = format.replace(/\\s?\\$\\s?/, '');\n\n            // format the number\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            // update the before and after based on value\n            if (value >= 0) {\n                symbols.before = symbols.before.replace(/[\\-\\(]/, '');\n                symbols.after = symbols.after.replace(/[\\-\\)]/, '');\n            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {\n                symbols.before = '-' + symbols.before;\n            }\n\n            // loop through each before symbol\n            for (i = 0; i < symbols.before.length; i++) {\n                symbol = symbols.before[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = numeral._.insert(output, locale.currency.symbol, i);\n                        break;\n                    case ' ':\n                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);\n                        break;\n                }\n            }\n\n            // loop through each after symbol\n            for (i = symbols.after.length - 1; i >= 0; i--) {\n                symbol = symbols.after[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                        break;\n                    case ' ':\n                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                        break;\n                }\n            }\n\n\n            return output;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'exponential', {\n        regexps: {\n            format: /(e\\+|e-)/,\n            unformat: /(e\\+|e-)/\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',\n                parts = exponential.split('e');\n\n            format = format.replace(/e[\\+|\\-]{1}0/, '');\n\n            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n\n            return output + 'e' + parts[1];\n        },\n        unformat: function(string) {\n            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),\n                value = Number(parts[0]),\n                power = Number(parts[1]);\n\n            power = numeral._.includes(string, 'e-') ? power *= -1 : power;\n\n            function cback(accum, curr, currI, O) {\n                var corrFactor = numeral._.correctionFactor(accum, curr),\n                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);\n                return num;\n            }\n\n            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'ordinal', {\n        regexps: {\n            format: /(o)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                output,\n                ordinal = numeral._.includes(format, ' o') ? ' ' : '';\n\n            // check for space before\n            format = format.replace(/\\s?o/, '');\n\n            ordinal += locale.ordinal(value);\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + ordinal;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'percentage', {\n        regexps: {\n            format: /(%)/,\n            unformat: /(%)/\n        },\n        format: function(value, format, roundingFunction) {\n            var space = numeral._.includes(format, ' %') ? ' ' : '',\n                output;\n\n            if (numeral.options.scalePercentBy100) {\n                value = value * 100;\n            }\n\n            // check for space before %\n            format = format.replace(/\\s?\\%/, '');\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            if (numeral._.includes(output, ')')) {\n                output = output.split('');\n\n                output.splice(-1, 0, space + '%');\n\n                output = output.join('');\n            } else {\n                output = output + space + '%';\n            }\n\n            return output;\n        },\n        unformat: function(string) {\n            var number = numeral._.stringToNumber(string);\n            if (numeral.options.scalePercentBy100) {\n                return number * 0.01;\n            }\n            return number;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'time', {\n        regexps: {\n            format: /(:)/,\n            unformat: /(:)/\n        },\n        format: function(value, format, roundingFunction) {\n            var hours = Math.floor(value / 60 / 60),\n                minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n\n            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n        },\n        unformat: function(string) {\n            var timeArray = string.split(':'),\n                seconds = 0;\n\n            // turn hours and minutes into seconds and add them all up\n            if (timeArray.length === 3) {\n                // hours\n                seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n                // minutes\n                seconds = seconds + (Number(timeArray[1]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[2]);\n            } else if (timeArray.length === 2) {\n                // minutes\n                seconds = seconds + (Number(timeArray[0]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[1]);\n            }\n            return Number(seconds);\n        }\n    });\n})();\n\nreturn numeral;\n}));\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n","import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables, mergeOptions } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  const defaultWatchQueryOptions = client.defaultOptions.watchQuery;\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options, defaultWatchQueryOptions),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options, defaultWatchQueryOptions);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (nextResult.error) {\n          options.onError?.(nextResult.error);\n        } else if (nextResult.data) {\n          options.onCompleted?.(nextResult.data);\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options, defaultWatchQueryOptions)).catch(() => {});\n    }\n\n    // We assign options during rendering as a guard to make sure that\n    // callbacks like onCompleted and onError are not stale.\n    Object.assign(ref.current, { options });\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: createWatchQueryOptions(query, options, defaultWatchQueryOptions).variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\n/**\n * A function to massage options before passing them the ObservableQuery.\n */\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n  defaultOptions?: Partial<WatchQueryOptions<any, any>>\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...otherOptions\n  } = options;\n\n  let watchQueryOptions = { query, ...otherOptions };\n  if (defaultOptions) {\n    watchQueryOptions = mergeOptions(defaultOptions, watchQueryOptions);\n  }\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {} as TVariables;\n  }\n\n  return watchQueryOptions;\n}\n","import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n"],"names":["createSvgIcon","_jsx","d","getAvatarUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","AvatarRoot","styled","name","overridesResolver","props","styles","ownerState","root","variant","colorDefault","theme","_extends","position","display","alignItems","justifyContent","flexShrink","width","height","fontFamily","typography","fontSize","pxToRem","lineHeight","borderRadius","overflow","userSelect","shape","color","palette","background","default","backgroundColor","mode","grey","AvatarImg","img","textAlign","objectFit","textIndent","AvatarFallback","Person","fallback","React","inProps","ref","useThemeProps","alt","childrenProp","children","className","component","imgProps","sizes","src","srcSet","other","_objectWithoutPropertiesLoose","loaded","crossOrigin","referrerPolicy","setLoaded","active","image","Image","onload","onerror","srcset","useLoaded","hasImg","hasImgNotFailing","classes","slots","composeClasses","useUtilityClasses","as","clsx","_construct","Parent","args","Class","isNativeReflectConstruct","Reflect","construct","a","push","apply","instance","Function","bind","setPrototypeOf","prototype","arguments","_wrapNativeSuper","_cache","Map","undefined","fn","toString","call","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","this","constructor","Object","create","value","enumerable","writable","configurable","isObjectLike","invariant","condition","message","Boolean","Error","LineRegExp","getLocation","source","lastLineStart","line","body","matchAll","match","index","length","column","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","slice","printPrefixedLines","map","subLine","existingLines","filter","padLen","max","prefix","join","toNormalizedArgs","firstArg","nodes","positions","path","originalError","extensions","GraphQLError","_this$nodes","_nodeLocations$","_ref","rawArgs","undefinedIfEmpty","Array","isArray","nodeLocations","node","loc","locations","pos","originalExtensions","defineProperties","stack","defineProperty","captureStackTrace","output","formattedError","keys","Symbol","toStringTag","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","Token","lastToken","token","lineStart","lookahead","kind","next","nextToken","readNextToken","end","prev","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","String","fromCodePoint","toUpperCase","createToken","col","bodyLength","readComment","readBlockString","readString","isDigit","readNumber","isNameStart","readName","firstCode","isFloat","readDigits","chunkStart","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","dedentBlockStringLines","isNameContinue","Parser","options","sourceObj","isSource","Source","_lexer","_options","expectToken","Kind","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","operation","OperationTypeNode","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseName","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","parseList","parseObject","advance","parseStringLiteral","varName","block","values","any","fields","parseObjectField","parseDirective","innerType","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","delimitedMany","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","types","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseEnumValueName","getTokenDesc","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","hasOwnProperty","startToken","_this$_options2","noLocation","Location","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","isPunctuatorTokenKind","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","console","warn","add","parseDocument","cacheKey","parsed","parse","doc","workSet","key","endToken","stripLoc","gql","literals","result","arg","gql_1","extras","clear","define","numeral","_","VERSION","formats","locales","defaults","currentLocale","zeroFormat","nullFormat","defaultFormat","scalePercentBy100","Numeral","input","number","_input","_value","unformatFunction","regexp","isNumeral","isNaN","regexps","unformat","stringToNumber","Number","version","obj","numberToFormat","format","roundingFunction","abbrForce","abs","int","precision","signed","thousands","locale","negP","optDec","leadingCount","abbr","trillion","billion","million","thousand","decimal","neg","includes","RegExp","abbreviations","toFixed","delimiters","abbreviation","stringOriginal","currency","symbol","pow","min","search","insert","subString","reduce","callback","t","len","k","multiplier","x","parts","correctionFactor","accum","mn","maxDecimals","optionals","boundedPrecision","optionalsRegExp","power","splitValue","minDecimals","toLowerCase","localeData","reset","property","register","validate","val","culture","_decimalSep","_thousandSep","_currSymbol","_valArray","_abbrObj","_thousandRegEx","temp","e","substr","clone","inputString","formatFunction","round","corrFactor","cback","curr","currI","O","subtract","multiply","divide","difference","ordinal","b","space","splice","base","suffixes","binary","unformatRegex","concat","bytes","suffix","bytesMultiplier","symbols","before","after","toExponential","hours","minutes","seconds","timeArray","DocumentType","cache","operationName","Query","Mutation","Subscription","verifyDocumentType","document","variables","cached","__DEV__","fragments","queries","mutations","subscriptions","definition","payload","requiredOperationName","useQuery","query","context","useContext","getApolloContext","client","override","useApolloClient","defaultWatchQueryOptions","defaultOptions","watchQuery","partial","useState","watchQueryOptions","createWatchQueryOptions","obsQuery","renderPromises","getSSRObservable","registerSSRObservable","ssr","skip","getCurrentResult","loading","addQueryPromise","getOptions","fetchData","Promise","resolve","sub","subscribe","unsubscribe","error","complete","setObsQuery","onError","_a","data","onCompleted","_b","setResult","useRef","previousData","useEffect","nextResult","current","equal","setOptions","catch","obsQuery_1","previousResult","assign","subscription","onNext","last","resetLastResults","networkStatus","NetworkStatus","disableNetworkFetches","partialRefetch","fetchPolicy","refetch","errors","ApolloError","graphQLErrors","obsQueryFields","useMemo","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","called","otherOptions","mergeOptions"],"sourceRoot":""}